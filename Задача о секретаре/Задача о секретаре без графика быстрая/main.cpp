#include <iostream>
#include <set>
#include <vector>
#include <stdlib.h>
#include <time.h>

using namespace std;

// Класс обсчета экспериментов
class Experiment{
private:
	vector < int > employee; // Рейтинги кандидатов
	int k; // Количество кандидатов, которых мы сразу отсеиваем
	int N; // Число людей в очереди
	int K; // Число экспериментов
	int Max; // Рейтинг лучшего кандидата

public:
	// Инициализация количеств людей в очереди и экспериментов
	Experiment(int _N = 100, int _K = 30000) {
		N = _N;
		K = _K;
		employee.resize(N);
	}

	// Инициализация рейтингов кандидатов
	void Init(int _k) {
		Max = -1; // Текущий максимальный рейтинг отрицательный => любой будет лучше
		k = _k; // Количество кандидатов, которых мы сразу отсеиваем
		int r; // Случайный рейтинг
		set < int > used; // множество уже занятых рейтингов
		used.clear(); // Сделать это множество пустым
		for (int i = 0; i < N; i++) { // Для каждого кандидата
			do
				r = rand(); // Сгенерируем случайный рейтинг
			while (used.count(r) > 0); // Пока этот рейтинг не занят
			employee[i] = r; // Присвоить кандидату рейтинг
			Max = max(r, Max); // Пересчитать текущий максимальный рейтинг
			used.insert(r); // Добавить этот рейтинг в множество занятых
		}
	}

	// Запуск одного эксперимента. Возвращает 1 в случае успеха и 0 - в случае неуспеха
	int Run_one() {
		int m = -1; // Текущий максимальный рейтинг отрицательный => первый же временно станет лучшим
		for (int i = 0; i < k; i++) // Для каждого из априорно отсеиваемых кандидатов
			m = max(m, employee[i]); // Смотрим, кто из них лучший
		for (int i = k; i < N; i++) // Смотрим на остальных кандидатов
			if (employee[i] > m) { // Если он лучше их
				if (employee[i] == Max) // Если он лучший из всех
					return 1; // Эксперимент удался
				else // Иначе
					return 0; // Мы выбрали не лучшего из них
			}
		if (employee[N - 1] == Max) // Если мы дошли до последнего, мы обязаны его взять. А лучший ли он?
			return 1; // Да
		return 0; // Нет
	}

	// Поиск вероятности выбора лучшего при априорном отсеивании к кандидатов
	double P(int _k) {
		double res = 0; // Число успешных исходов
		for (int i = 0; i < K; i++) { // Запуск серии экспериментов
			Init(_k); // Инициализировать рейтинг кандидатов
			res += Run_one(); // В случае успеха res учеличится на 1
		}
		return res / K; // Число успешных к числу неуспешных
	}

	// Запуск всего эксперимента
	void Run() {
		double p; // Вероятность выбора лучшего
		int m = 0; // При каком количестве априорного отсева у нас максимальна вероятность выбрать наилучшего
		double pmax = -1; // Вероятность при наилучшем кол-ве отсева
		for (int k = 0; k < N ; k++) { // При отсеве от 0 до N-1
			p = P(k); // Рассчитать вероятность
			cout << "P(" << k << ") = " << p << endl; // Вывести её на экран
			if (p > pmax) { // Если данное количество априорного отсева лучше
				m = k; // Изменить номер максимума
				pmax = p; // Изменить максимум
			}
		}
		cout << "best is << " << m << endl; // Вывесли наилучшее число априорного отсева
	}

};

int main(int argc, char *argv[]) {
    srand(time(NULL));
	Experiment Ex(100, 30000); // Инициализация числа экспериментов
	cerr << "Inited" << endl; // Вывести на экран хоть что-то, чтобы не было ощущения, что он завис
	Ex.Run(); // Запустить весь эксперимент
				 // ИМХО - там что-то странное творится в самом конце, когда мы априори отсеиваем N-1 кандидатов.
				 // Теоретически там вероятность выбора лучшего должна быть 0.01, а у меня раза в 2 больше Х_Х
	system("pause"); // После завершения не сразу выйти, а подождать нажатия любой клавиши
	return 0;
}
